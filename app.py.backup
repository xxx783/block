from flask import Flask, render_template, redirect, url_for, flash, request, session, jsonify
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
import pytz
import markdown
import re
import os
from functools import wraps

# 初始化Flask应用
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-here'

# 使用绝对路径指定数据库位置，避免权限问题
import os
db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'app.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# 初始化扩展
db = SQLAlchemy(app)

# 提前定义并注册utc_to_beijing过滤器
def utc_to_beijing_filter(dt):
    """将UTC时间转换为北京时间"""
    if dt:
        beijing_tz = pytz.timezone('Asia/Shanghai')
        return dt.astimezone(beijing_tz)
    return dt

# 确保过滤器在应用启动时就被注册到Jinja2环境中
app.jinja_env.filters['utc_to_beijing'] = utc_to_beijing_filter

# 模型定义
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    is_admin = db.Column(db.Boolean, default=False)
    is_vip = db.Column(db.Boolean, default=False)
    is_banned = db.Column(db.Boolean, default=False)
    vip_expires_at = db.Column(db.DateTime)
    vip_level = db.Column(db.Integer, default=0)
    
    # 关系
    articles = db.relationship('Article', backref='author', lazy=True)
    comments = db.relationship('Comment', backref='author', lazy=True)
    favorites = db.relationship('Favorite', backref='user', lazy=True)
    likes = db.relationship('Like', backref='user', lazy=True)
    user_points = db.relationship('UserPoints', backref='user', uselist=False, lazy=True)

class Article(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc), onupdate=lambda: datetime.now(pytz.utc))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    vip_only = db.Column(db.Boolean, default=False)
    vip_level_required = db.Column(db.Integer, default=0)
    
    # 关系
    comments = db.relationship('Comment', backref='article', lazy=True, cascade='all, delete-orphan')
    favorites = db.relationship('Favorite', backref='article', lazy=True, cascade='all, delete-orphan')
    likes = db.relationship('Like', backref='article', lazy=True, cascade='all, delete-orphan')

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    article_id = db.Column(db.Integer, db.ForeignKey('article.id'), nullable=False)
    is_pinned = db.Column(db.Boolean, default=False)

class Favorite(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    article_id = db.Column(db.Integer, db.ForeignKey('article.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    
    __table_args__ = (db.UniqueConstraint('user_id', 'article_id', name='unique_favorite'),)

class Like(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    article_id = db.Column(db.Integer, db.ForeignKey('article.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    
    __table_args__ = (db.UniqueConstraint('user_id', 'article_id', name='unique_like'),)

class UserPoints(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    total_points = db.Column(db.Integer, default=0)
    available_points = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc), onupdate=lambda: datetime.now(pytz.utc))

class Announcement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # 关系
    creator = db.relationship('User')

class VersionUpdate(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    version = db.Column(db.String(20), nullable=False)
    release_date = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    content = db.Column(db.Text, nullable=False)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    
    # 关系
    creator = db.relationship('User')

class Collection(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    
    # 关系
    user = db.relationship('User', backref='collections')

class SourceArticleCollection(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    article_id = db.Column(db.Integer, db.ForeignKey('article.id'), nullable=False)
    collection_id = db.Column(db.Integer, db.ForeignKey('collection.id'), nullable=False)
    added_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    
    __table_args__ = (db.UniqueConstraint('article_id', 'collection_id', name='unique_article_collection'),)

class PointTask(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    points = db.Column(db.Integer, default=0)
    task_type = db.Column(db.String(50), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))

class PointTaskCompletion(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    task_id = db.Column(db.Integer, db.ForeignKey('point_task.id'), nullable=False)
    completed_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))
    points_awarded = db.Column(db.Integer, default=0)
    
    __table_args__ = (db.UniqueConstraint('user_id', 'task_id', name='unique_task_completion'),)

class PointRedemption(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    points_required = db.Column(db.Integer, default=0)
    type = db.Column(db.String(50), nullable=False)
    value = db.Column(db.String(200), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(pytz.utc))

# 自定义过滤器和上下文处理器
@app.template_filter('utc_to_beijing')
def utc_to_beijing_filter(dt):
    if dt:
        beijing_tz = pytz.timezone('Asia/Shanghai')
        return dt.astimezone(beijing_tz)
    return dt

@app.template_filter('markdown')
def markdown_filter(text):
    return markdown.markdown(text)

@app.template_filter('format_date')
def format_date_filter(dt, format_str='%Y-%m-%d %H:%M'):
    if dt:
        return dt.strftime(format_str)
    return ''

@app.context_processor
def inject_global_vars():
    # 创建一个简单的匿名用户类，确保即使未登录时也能访问属性而不报错
    class AnonymousUser:
        def __init__(self):
            self.is_vip = False
            self.vip_level = 0
            self.vip_expires_at = None
    
    user = AnonymousUser()  # 默认使用匿名用户对象
    is_logged_in = False
    is_admin = False
    is_vip = False
    vip_expires_at = None
    
    if 'user_id' in session:
        db_user = User.query.get(session['user_id'])
        if db_user and not db_user.is_banned:
            user = db_user  # 登录状态下使用实际用户对象
            is_logged_in = True
            is_admin = user.is_admin
            is_vip = user.is_vip and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))
            vip_expires_at = user.vip_expires_at
    
    # 获取最新公告
    latest_announcement = Announcement.query.order_by(Announcement.created_at.desc()).first()
    
    return {
        'is_logged_in': is_logged_in,
        'current_user': user,
        'is_admin': is_admin,
        'is_vip': is_vip,
        'vip_expires_at': vip_expires_at,
        'latest_announcement': latest_announcement,
        'now': datetime.now(pytz.utc)
    }

@app.context_processor
def inject_functions():
    def get_vip_type(user):
        if user and user.is_vip:
            if user.vip_expires_at and user.vip_expires_at < datetime.now(pytz.utc):
                return '会员已过期'
            if user.vip_level == 1:
                return '超级会员'
            return '会员'
        return ''
    
    def get_article_stats(article):
        comments_count = len(article.comments) if article.comments else 0
        likes_count = len(article.likes) if article.likes else 0
        favorites_count = len(article.favorites) if article.favorites else 0
        return {'comments': comments_count, 'likes': likes_count, 'favorites': favorites_count}
    
    return {
        'get_vip_type': get_vip_type,
        'get_article_stats': get_article_stats
    }

# 添加空的csrf_token上下文处理器，避免模板中调用csrf_token()出错
@app.context_processor
def inject_csrf_token():
    def csrf_token():
        return ''
    return {'csrf_token': csrf_token}

# 装饰器
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('请先登录', 'warning')
            return redirect(url_for('login', next=request.url))
        user = User.query.get(session['user_id'])
        if not user or user.is_banned:
            session.pop('user_id', None)
            flash('您的账户已被禁用', 'danger')
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('请先登录', 'warning')
            return redirect(url_for('login', next=request.url))
        user = User.query.get(session['user_id'])
        if not user or user.is_banned or not user.is_admin:
            flash('您没有权限访问此页面', 'danger')
            return redirect(url_for('index'))
        return f(*args, **kwargs)
    return decorated_function

def vip_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('请先登录', 'warning')
            return redirect(url_for('login', next=request.url))
        user = User.query.get(session['user_id'])
        if not user or user.is_banned:
            session.pop('user_id', None)
            flash('您的账户已被禁用', 'danger')
            return redirect(url_for('login'))
        if not user.is_vip or (user.vip_expires_at and user.vip_expires_at < datetime.now(pytz.utc)):
            flash('此功能需要会员权限', 'warning')
            return redirect(url_for('index'))
        return f(*args, **kwargs)
    return decorated_function

# 路由
@app.route('/')
def index():
    # 获取最新文章，不包括被禁用户的文章
    articles = Article.query.join(User).filter(User.is_banned == False).order_by(Article.created_at.desc()).limit(20).all()
    return render_template('index.html', articles=articles)

@app.route('/community')
def community():
    # 获取社区文章列表，不包括被禁用户的文章
    articles = Article.query.join(User).filter(User.is_banned == False).order_by(Article.created_at.desc()).limit(20).all()
    return render_template('community.html', articles=articles)

@app.route('/about')
def about():
    return render_template('about.html')

@app.route('/my_collections')
@login_required
def my_collections():
    user = User.query.get(session['user_id'])
    collections = Collection.query.filter_by(user_id=user.id).order_by(Collection.created_at.desc()).all()
    
    # 计算每个合集的文章数量
    for collection in collections:
        collection.article_count = SourceArticleCollection.query.filter_by(collection_id=collection.id).count()
        
    return render_template('my_collections.html', collections=collections)

@app.route('/create_collection', methods=['GET', 'POST'])
@login_required
def create_collection():
    if request.method == 'POST':
        name = request.form.get('name')
        description = request.form.get('description')
        is_public = request.form.get('is_public') == 'on'
        
        # 验证输入
        if not name or len(name.strip()) == 0:
            flash('合集名称不能为空', 'danger')
            return redirect(url_for('create_collection'))
            
        # 创建新合集
        new_collection = Collection(
            name=name.strip(),
            description=description.strip() if description else '',
            is_public=is_public,
            user_id=session['user_id'],
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(new_collection)
        db.session.commit()
        
        flash('合集创建成功！', 'success')
        return redirect(url_for('my_collections'))
        
    return render_template('create_collection.html')

@app.route('/my_favorites')
@login_required
def my_favorites():
    user = User.query.get(session['user_id'])
    
    # 查询用户收藏的文章
    favorites = Favorite.query.filter_by(user_id=user.id).order_by(Favorite.created_at.desc()).all()
    
    # 获取收藏的文章ID列表
    article_ids = [favorite.article_id for favorite in favorites]
    
    # 查询所有收藏的文章
    articles = Article.query.filter(Article.id.in_(article_ids), Article.author.has(is_banned=False)).all()
    
    # 按收藏时间排序文章
    article_dict = {article.id: article for article in articles}
    sorted_articles = [article_dict[article_id] for article_id in article_ids if article_id in article_dict]
    
    # 为每篇文章计算点赞数和收藏数，并检查是否已点赞
    for article in sorted_articles:
        article.like_count = Like.query.filter_by(article_id=article.id).count()
        article.favorite_count = Favorite.query.filter_by(article_id=article.id).count()
        article.is_liked = Like.query.filter_by(user_id=user.id, article_id=article.id).first() is not None
        article.is_favorited = True  # 因为这些文章已经在收藏列表中
    
    return render_template('my_favorites.html', articles=sorted_articles)

@app.route('/points_center')
@login_required
def points_center():
    user = User.query.get(session['user_id'])
    
    # 获取用户积分信息
    user_points = UserPoints.query.filter_by(user_id=user.id).first()
    if not user_points:
        # 如果用户没有积分记录，创建一个
        user_points = UserPoints(user_id=user.id, total_points=0, available_points=0)
        db.session.add(user_points)
        db.session.commit()
    
    # 获取所有可用的任务
    tasks = PointTask.query.filter_by(is_active=True).all()
    
    # 为每个任务检查用户是否可以完成
    for task in tasks:
        can_complete, message = can_complete_task(user.id, task.id)
        task.can_complete = can_complete
        task.message = message
    
    # 设置VIP兑换选项
    vip_options = [
        {'name': '7天会员', 'days': 7, 'points': 100, 'description': '体验一周会员特权'},
        {'name': '30天会员', 'days': 30, 'points': 300, 'description': '一个月会员特权'},
        {'name': '90天会员', 'days': 90, 'points': 750, 'description': '三个月会员特权，享9折优惠'},
        {'name': '365天会员', 'days': 365, 'points': 2800, 'description': '一年会员特权，享7折优惠'}
    ]
    
    return render_template('points.html', 
                           total_points=user_points.total_points, 
                           available_points=user_points.available_points, 
                           tasks=tasks, 
                           vip_options=vip_options)

def can_complete_task(user_id, task_id):
    """检查用户是否可以完成指定任务"""
    task = PointTask.query.get(task_id)
    if not task or not task.is_active:
        return False, "任务不存在或已关闭"
    
    # 检查用户是否已经完成过此任务
    existing_completion = PointTaskCompletion.query.filter_by(
        user_id=user_id, 
        task_id=task_id
    ).first()
    
    # 对于每日任务，需要检查是否在24小时内已经完成
    if task.task_type == 'daily':
        # 如果任务已经完成，检查是否超过24小时
        if existing_completion:
            time_since_completion = datetime.now(pytz.utc) - existing_completion.completed_at
            if time_since_completion < timedelta(hours=24):
                hours_left = 24 - time_since_completion.total_seconds() / 3600
                return False, f"请在{int(hours_left)}小时后再来完成此任务"
            return True, "可以再次完成此任务"
        return True, "可以完成此任务"
    
    # 对于一次性任务，检查是否已经完成过
    elif task.task_type == 'one_time':
        if existing_completion:
            return False, "此任务只能完成一次"
        return True, "可以完成此任务"
    
    # 其他类型的任务默认可以完成
    return True, "可以完成此任务"

@app.route('/complete_task/<int:task_id>', methods=['POST'])
@login_required
def complete_task(task_id):
    user_id = session['user_id']
    user = User.query.get(user_id)
    
    # 检查用户是否可以完成此任务
    can_complete, message = can_complete_task(user_id, task_id)
    if not can_complete:
        return jsonify({'success': False, 'message': message})
    
    task = PointTask.query.get(task_id)
    
    try:
        # 获取用户积分记录
        user_points = UserPoints.query.filter_by(user_id=user_id).first()
        if not user_points:
            user_points = UserPoints(user_id=user_id, total_points=0, available_points=0)
            db.session.add(user_points)
        
        # 更新用户积分
        user_points.total_points += task.points
        user_points.available_points += task.points
        user_points.updated_at = datetime.now(pytz.utc)
        
        # 记录任务完成情况
        # 对于每日任务，先删除之前的完成记录
        if task.task_type == 'daily':
            existing_completion = PointTaskCompletion.query.filter_by(
                user_id=user_id, 
                task_id=task_id
            ).first()
            if existing_completion:
                db.session.delete(existing_completion)
        
        # 创建新的任务完成记录
        completion = PointTaskCompletion(
            user_id=user_id,
            task_id=task_id,
            points_awarded=task.points
        )
        db.session.add(completion)
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'任务完成！获得{task.points}积分',
            'new_points': user_points.available_points
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': '操作失败，请稍后重试'})

@app.route('/redeem_vip/<int:days>', methods=['POST'])
@login_required
def redeem_vip(days):
    user_id = session['user_id']
    user = User.query.get(user_id)
    
    # 根据天数确定所需积分
    points_required = 0
    if days == 7:
        points_required = 100
    elif days == 30:
        points_required = 300
    elif days == 90:
        points_required = 750
    elif days == 365:
        points_required = 2800
    else:
        return jsonify({'success': False, 'message': '无效的会员天数'})
    
    # 获取用户积分记录
    user_points = UserPoints.query.filter_by(user_id=user_id).first()
    if not user_points or user_points.available_points < points_required:
        return jsonify({'success': False, 'message': '积分不足'})
    
    try:
        # 扣除积分
        user_points.available_points -= points_required
        user_points.updated_at = datetime.now(pytz.utc)
        
        # 设置会员状态
        user.is_vip = True
        user.vip_level = 1  # 默认设置为普通会员
        
        # 如果用户已有会员，将会员有效期延长
        if user.vip_expires_at and user.vip_expires_at > datetime.now(pytz.utc):
            user.vip_expires_at += timedelta(days=days)
        else:
            user.vip_expires_at = datetime.now(pytz.utc) + timedelta(days=days)
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'成功兑换{days}天会员！',
            'new_points': user_points.available_points,
            'vip_expires_at': user.vip_expires_at.strftime('%Y-%m-%d %H:%M:%S')
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': '操作失败，请稍后重试'})

@app.route('/login', methods=['GET', 'POST'])
def login():
    if 'user_id' in session:
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if not username or not password:
            flash('请输入用户名和密码', 'danger')
            return redirect(url_for('login'))
        
        user = User.query.filter_by(username=username).first()
        if not user or not check_password_hash(user.password, password):
            flash('用户名或密码错误', 'danger')
            return redirect(url_for('login'))
        
        if user.is_banned:
            flash('您的账户已被禁用', 'danger')
            return redirect(url_for('login'))
        
        # 登录成功，设置会话
        session['user_id'] = user.id
        session['username'] = user.username
        session['is_admin'] = user.is_admin
        session['is_vip'] = user.is_vip and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))
        
        flash('登录成功', 'success')
        next_url = request.args.get('next')
        return redirect(next_url or url_for('index'))
    
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if 'user_id' in session:
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        
        # 验证表单数据
        if not username or not email or not password or not confirm_password:
            flash('请填写所有必填字段', 'danger')
            return redirect(url_for('register'))
        
        if password != confirm_password:
            flash('两次输入的密码不一致', 'danger')
            return redirect(url_for('register'))
        
        # 检查用户名和邮箱是否已存在
        if User.query.filter_by(username=username).first():
            flash('用户名已被注册', 'danger')
            return redirect(url_for('register'))
        
        if User.query.filter_by(email=email).first():
            flash('邮箱已被注册', 'danger')
            return redirect(url_for('register'))
        
        # 创建新用户
        hashed_password = generate_password_hash(password)
        new_user = User(
            username=username,
            email=email,
            password=hashed_password
        )
        
        # 创建用户积分记录
        user_points = UserPoints(user_id=new_user.id)
        
        try:
            db.session.add(new_user)
            db.session.add(user_points)
            db.session.commit()
            flash('注册成功，请登录', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            db.session.rollback()
            flash('注册失败，请稍后重试', 'danger')
            return redirect(url_for('register'))
    
    return render_template('register.html')

@app.route('/logout')
def logout():
    session.clear()
    flash('已成功退出登录', 'success')
    return redirect(url_for('login'))

@app.route('/article/<int:article_id>')
def view_article(article_id):
    article = Article.query.get_or_404(article_id)
    
    # 检查用户是否有权限查看
    if article.vip_only:
        user = None
        if 'user_id' in session:
            user = User.query.get(session['user_id'])
        
        if not user or user.is_banned:
            flash('请先登录查看此文章', 'warning')
            return redirect(url_for('login', next=request.url))
        
        if not user.is_vip or (user.vip_expires_at and user.vip_expires_at < datetime.now(pytz.utc)):
            flash('此文章需要会员权限', 'warning')
            return redirect(url_for('index'))
        
        if article.vip_level_required > user.vip_level:
            flash('此文章需要超级会员权限', 'warning')
            return redirect(url_for('index'))
    
    # 获取评论
    comments = Comment.query.filter_by(article_id=article_id).order_by(Comment.is_pinned.desc(), Comment.created_at.desc()).all()
    
    # 检查是否已收藏和点赞
    is_favorited = False
    is_liked = False
    if 'user_id' in session:
        is_favorited = Favorite.query.filter_by(user_id=session['user_id'], article_id=article_id).first() is not None
        is_liked = Like.query.filter_by(user_id=session['user_id'], article_id=article_id).first() is not None
    
    return render_template('view_article.html', article=article, comments=comments, is_favorited=is_favorited, is_liked=is_liked)

@app.route('/create_article', methods=['GET', 'POST'])
@login_required
def create_article():
    user = User.query.get(session['user_id'])
    user_collections = Collection.query.filter_by(user_id=user.id).all()
    
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        vip_only = request.form.get('vip_only') == 'on'
        vip_level = int(request.form.get('vip_level', 0))
        collection_id = request.form.get('collection_id')
        
        # 验证表单数据
        if not title or not content:
            flash('请填写标题和内容', 'danger')
            return redirect(url_for('create_article'))
        
        # 检查VIP权限
        if vip_only and not (user.is_vip and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))):
            flash('只有会员才能发布会员专属文章', 'danger')
            return redirect(url_for('create_article'))
        
        if vip_level == 1 and not (user.is_vip and user.vip_level == 1 and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))):
            flash('只有超级会员才能发布超级会员专属文章', 'danger')
            return redirect(url_for('create_article'))
        
        # 创建新文章
        new_article = Article(
            title=title,
            content=content,
            user_id=user.id,
            vip_only=vip_only,
            vip_level_required=vip_level
        )
        
        try:
            db.session.add(new_article)
            db.session.commit()
            
            # 添加到合集
            if collection_id and collection_id.isdigit():
                collection = Collection.query.get(int(collection_id))
                if collection and collection.user_id == user.id:
                    article_collection = SourceArticleCollection(article_id=new_article.id, collection_id=collection.id)
                    db.session.add(article_collection)
                    db.session.commit()
            
            flash('文章创建成功', 'success')
            return redirect(url_for('view_article', article_id=new_article.id))
        except Exception as e:
            db.session.rollback()
            flash('文章创建失败，请稍后重试', 'danger')
            return redirect(url_for('create_article'))
    
    return render_template('create_article.html', user_collections=user_collections)

@app.route('/edit_article/<int:article_id>', methods=['GET', 'POST'])
@login_required
def edit_article(article_id):
    article = Article.query.get_or_404(article_id)
    user = User.query.get(session['user_id'])
    
    # 检查权限
    if article.user_id != user.id and not user.is_admin:
        flash('您没有权限编辑此文章', 'danger')
        return redirect(url_for('view_article', article_id=article_id))
    
    user_collections = Collection.query.filter_by(user_id=user.id).all()
    
    # 获取文章当前所在的合集
    current_collection = SourceArticleCollection.query.filter_by(article_id=article_id).first()
    current_collection_id = current_collection.collection_id if current_collection else None
    
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        vip_only = request.form.get('vip_only') == 'on'
        vip_level = int(request.form.get('vip_level', 0))
        collection_id = request.form.get('collection_id')
        
        # 验证表单数据
        if not title or not content:
            flash('请填写标题和内容', 'danger')
            return redirect(url_for('edit_article', article_id=article_id))
        
        # 检查VIP权限
        if vip_only and not (user.is_vip and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))) and not user.is_admin:
            flash('只有会员才能发布会员专属文章', 'danger')
            return redirect(url_for('edit_article', article_id=article_id))
        
        if vip_level == 1 and not (user.is_vip and user.vip_level == 1 and (not user.vip_expires_at or user.vip_expires_at > datetime.now(pytz.utc))) and not user.is_admin:
            flash('只有超级会员才能发布超级会员专属文章', 'danger')
            return redirect(url_for('edit_article', article_id=article_id))
        
        # 更新文章
        article.title = title
        article.content = content
        article.vip_only = vip_only
        article.vip_level_required = vip_level
        
        try:
            db.session.commit()
            
            # 处理合集关系
            if collection_id and collection_id.isdigit():
                # 先删除现有关系
                if current_collection:
                    db.session.delete(current_collection)
                    db.session.commit()
                
                # 添加新关系
                collection = Collection.query.get(int(collection_id))
                if collection and collection.user_id == user.id:
                    article_collection = SourceArticleCollection(article_id=article.id, collection_id=collection.id)
                    db.session.add(article_collection)
                    db.session.commit()
            elif current_collection:
                # 如果选择了不添加到任何合集，且之前有合集关系，则删除
                db.session.delete(current_collection)
                db.session.commit()
            
            flash('文章更新成功', 'success')
            return redirect(url_for('view_article', article_id=article.id))
        except Exception as e:
            db.session.rollback()
            flash('文章更新失败，请稍后重试', 'danger')
            return redirect(url_for('edit_article', article_id=article_id))
    
    return render_template('edit_article.html', article=article, user_collections=user_collections, current_collection_id=current_collection_id)

@app.route('/delete_article/<int:article_id>', methods=['POST'])
@login_required
def delete_article(article_id):
    article = Article.query.get_or_404(article_id)
    user = User.query.get(session['user_id'])
    
    # 检查权限
    if article.user_id != user.id and not user.is_admin:
        flash('您没有权限删除此文章', 'danger')
        return redirect(url_for('view_article', article_id=article_id))
    
    try:
        db.session.delete(article)
        db.session.commit()
        flash('文章删除成功', 'success')
        return redirect(url_for('my_articles'))
    except Exception as e:
        db.session.rollback()
        flash('文章删除失败，请稍后重试', 'danger')
        return redirect(url_for('view_article', article_id=article_id))

@app.route('/my_articles')
@login_required
def my_articles():
    user = User.query.get(session['user_id'])
    articles = Article.query.filter_by(user_id=user.id).order_by(Article.created_at.desc()).all()
    return render_template('my_articles.html', articles=articles)

@app.route('/user/<username>')
def user_profile(username):
    user = User.query.filter_by(username=username).first_or_404()
    
    # 不显示被禁用户的文章
    articles = Article.query.filter_by(user_id=user.id).join(User).filter(User.is_banned == False).order_by(Article.created_at.desc()).all()
    
    # 获取收藏和点赞数量
    favorite_count = Favorite.query.filter_by(user_id=user.id).count()
    like_count = Like.query.filter_by(user_id=user.id).count()
    
    return render_template('user_profile.html', user=user, articles=articles, favorite_count=favorite_count, like_count=like_count)

@app.route('/admin/dashboard')
@admin_required
def admin_dashboard():
    users = User.query.order_by(User.created_at.desc()).all()
    articles = Article.query.order_by(Article.created_at.desc()).all()
    announcements = Announcement.query.order_by(Announcement.created_at.desc()).all()
    return render_template('admin/dashboard.html', users=users, articles=articles, announcements=announcements)

@app.route('/admin/point_tasks')
@admin_required
def admin_point_tasks():
    tasks = PointTask.query.order_by(PointTask.created_at.desc()).all()
    return render_template('admin/point_tasks.html', tasks=tasks)

@app.route('/admin/edit_point_task/<int:task_id>', methods=['GET', 'POST'])
@admin_required
def edit_point_task(task_id):
    # 如果task_id为0，表示创建新任务
    if task_id == 0:
        task = None
    else:
        task = PointTask.query.get_or_404(task_id)
    
    if request.method == 'POST':
        name = request.form.get('name')
        description = request.form.get('description')
        points = int(request.form.get('points'))
        max_completions = int(request.form.get('max_completions'))
        cooldown_hours = int(request.form.get('cooldown_hours'))
        is_active = request.form.get('is_active') == 'true'
        
        # 验证输入
        if not name or len(name.strip()) == 0:
            flash('任务名称不能为空', 'danger')
            return redirect(url_for('edit_point_task', task_id=task_id))
        
        if points <= 0:
            flash('积分奖励必须大于0', 'danger')
            return redirect(url_for('edit_point_task', task_id=task_id))
        
        if cooldown_hours < 0:
            flash('冷却时间不能为负数', 'danger')
            return redirect(url_for('edit_point_task', task_id=task_id))
        
        # 创建或更新任务
        if not task:
            new_task = PointTask(
                name=name.strip(),
                description=description.strip() if description else '',
                points=points,
                max_completions=max_completions,
                cooldown_hours=cooldown_hours,
                is_active=is_active,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            db.session.add(new_task)
            flash('任务创建成功！', 'success')
        else:
            task.name = name.strip()
            task.description = description.strip() if description else ''
            task.points = points
            task.max_completions = max_completions
            task.cooldown_hours = cooldown_hours
            task.is_active = is_active
            task.updated_at = datetime.utcnow()
            flash('任务更新成功！', 'success')
        
        db.session.commit()
        return redirect(url_for('admin_point_tasks'))
    
    return render_template('admin/edit_point_task.html', task=task)

@app.route('/admin/create_point_task', methods=['GET', 'POST'])
@admin_required
def create_point_task():
    # 重定向到编辑任务路由，传入task_id=0表示创建新任务
    return redirect(url_for('edit_point_task', task_id=0))

# 评论相关路由
@app.route('/article/<int:article_id>/comment', methods=['POST'])
@login_required
def add_comment(article_id):
    article = Article.query.get_or_404(article_id)
    user = User.query.get(session['user_id'])
    
    content = request.form.get('content')
    if not content or len(content.strip()) == 0:
        flash('评论内容不能为空', 'danger')
        return redirect(url_for('view_article', article_id=article_id))
    
    new_comment = Comment(content=content, user_id=user.id, article_id=article_id)
    
    try:
        db.session.add(new_comment)
        db.session.commit()
        flash('评论发表成功', 'success')
    except Exception as e:
        db.session.rollback()
        flash('评论发表失败，请稍后重试', 'danger')
    
    return redirect(url_for('view_article', article_id=article_id))

@app.route('/comment/<int:comment_id>/delete', methods=['POST'])
@login_required
def delete_comment(comment_id):
    comment = Comment.query.get_or_404(comment_id)
    user = User.query.get(session['user_id'])
    
    # 检查权限
    if comment.user_id != user.id and not user.is_admin and comment.article.user_id != user.id:
        flash('您没有权限删除此评论', 'danger')
        return redirect(url_for('view_article', article_id=comment.article_id))
    
    try:
        db.session.delete(comment)
        db.session.commit()
        flash('评论删除成功', 'success')
    except Exception as e:
        db.session.rollback()
        flash('评论删除失败，请稍后重试', 'danger')
    
    return redirect(url_for('view_article', article_id=comment.article_id))

# 收藏和点赞相关路由
@app.route('/article/<int:article_id>/favorite', methods=['POST'])
@login_required
def toggle_favorite(article_id):
    article = Article.query.get_or_404(article_id)
    user = User.query.get(session['user_id'])
    
    favorite = Favorite.query.filter_by(user_id=user.id, article_id=article_id).first()
    
    try:
        if favorite:
            db.session.delete(favorite)
            db.session.commit()
            flash('已取消收藏', 'success')
        else:
            new_favorite = Favorite(user_id=user.id, article_id=article_id)
            db.session.add(new_favorite)
            db.session.commit()
            flash('收藏成功', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('view_article', article_id=article_id))

@app.route('/article/<int:article_id>/like', methods=['POST'])
@login_required
def toggle_like(article_id):
    article = Article.query.get_or_404(article_id)
    user = User.query.get(session['user_id'])
    
    like = Like.query.filter_by(user_id=user.id, article_id=article_id).first()
    
    try:
        if like:
            db.session.delete(like)
            db.session.commit()
            flash('已取消点赞', 'success')
        else:
            new_like = Like(user_id=user.id, article_id=article_id)
            db.session.add(new_like)
            db.session.commit()
            flash('点赞成功', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('view_article', article_id=article_id))

# 管理员用户管理路由
@app.route('/admin/user/<int:user_id>/ban', methods=['POST'])
@admin_required
def admin_ban_user(user_id):
    user = User.query.get_or_404(user_id)
    
    # 不能封禁管理员
    if user.is_admin:
        flash('不能封禁管理员', 'danger')
        return redirect(url_for('admin_dashboard'))
    
    user.is_banned = True
    
    try:
        db.session.commit()
        flash(f'用户 {user.username} 已被封禁', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/user/<int:user_id>/unban', methods=['POST'])
@admin_required
def admin_unban_user(user_id):
    user = User.query.get_or_404(user_id)
    user.is_banned = False
    
    try:
        db.session.commit()
        flash(f'用户 {user.username} 已被解封', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/user/<int:user_id>/set_vip', methods=['POST'])
@admin_required
def admin_set_vip(user_id):
    user = User.query.get_or_404(user_id)
    vip_level = int(request.form.get('vip_level', 0))
    
    user.is_vip = True
    user.vip_level = vip_level
    # 设置会员有效期为30天
    user.vip_expires_at = datetime.now(pytz.utc) + timedelta(days=30)
    
    try:
        db.session.commit()
        vip_type = '超级会员' if vip_level == 1 else '会员'
        flash(f'用户 {user.username} 已设置为{vip_type}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('admin_dashboard'))

@app.route('/admin/user/<int:user_id>/remove_vip', methods=['POST'])
@admin_required
def admin_remove_vip(user_id):
    user = User.query.get_or_404(user_id)
    
    user.is_vip = False
    user.vip_level = 0
    user.vip_expires_at = None
    
    try:
        db.session.commit()
        flash(f'已取消用户 {user.username} 的会员资格', 'success')
    except Exception as e:
        db.session.rollback()
        flash('操作失败，请稍后重试', 'danger')
    
    return redirect(url_for('admin_dashboard'))

# 公告管理路由
@app.route('/admin/create_announcement', methods=['GET', 'POST'])
@admin_required
def admin_create_announcement():
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        
        if not title or not content:
            flash('请填写标题和内容', 'danger')
            return redirect(url_for('admin_create_announcement'))
        
        new_announcement = Announcement(
            title=title,
            content=content,
            created_by=session['user_id']
        )
        
        try:
            db.session.add(new_announcement)
            db.session.commit()
            flash('公告创建成功', 'success')
            return redirect(url_for('admin_dashboard'))
        except Exception as e:
            db.session.rollback()
            flash('公告创建失败，请稍后重试', 'danger')
            return redirect(url_for('admin_create_announcement'))
    
    return render_template('admin/create_announcement.html')

# 版本更新管理路由
@app.route('/admin/create_version', methods=['GET', 'POST'])
@admin_required
def admin_create_version():
    if request.method == 'POST':
        version = request.form.get('version')
        content = request.form.get('content')
        
        if not version or not content:
            flash('请填写版本号和更新内容', 'danger')
            return redirect(url_for('admin_create_version'))
        
        # 停用所有旧版本
        VersionUpdate.query.update({'is_active': False})
        
        new_version = VersionUpdate(
            version=version,
            content=content,
            created_by=session['user_id'],
            is_active=True
        )
        
        try:
            db.session.add(new_version)
            db.session.commit()
            flash('版本更新记录创建成功', 'success')
            return redirect(url_for('admin_versions'))
        except Exception as e:
            db.session.rollback()
            flash('操作失败，请稍后重试', 'danger')
            return redirect(url_for('admin_create_version'))
    
    return render_template('admin/create_version.html')

@app.route('/admin/versions')
@admin_required
def admin_versions():
    versions = VersionUpdate.query.order_by(VersionUpdate.created_at.desc()).all()
    return render_template('admin/versions.html', versions=versions)

# 错误处理
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

# API路由
@app.route('/api/articles', methods=['GET'])
def api_articles():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    pagination = Article.query.join(User).filter(User.is_banned == False).order_by(Article.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
    articles = pagination.items
    
    result = {
        'articles': [{
            'id': article.id,
            'title': article.title,
            'author': article.author.username,
            'created_at': article.created_at.isoformat(),
            'vip_only': article.vip_only,
            'vip_level_required': article.vip_level_required,
            'comments_count': len(article.comments),
            'likes_count': len(article.likes)
        } for article in articles],
        'total': pagination.total,
        'pages': pagination.pages,
        'page': pagination.page
    }
    
    return jsonify(result)

@app.route('/api/article/<int:article_id>', methods=['GET'])
def api_article(article_id):
    article = Article.query.get_or_404(article_id)
    
    result = {
        'id': article.id,
        'title': article.title,
        'content': article.content,
        'author': article.author.username,
        'created_at': article.created_at.isoformat(),
        'updated_at': article.updated_at.isoformat(),
        'vip_only': article.vip_only,
        'vip_level_required': article.vip_level_required,
        'comments_count': len(article.comments),
        'likes_count': len(article.likes),
        'favorites_count': len(article.favorites)
    }
    
    return jsonify(result)

# 确保数据库表存在（注意：这里不创建新表，只确保现有表可访问）
with app.app_context():
    # 不使用db.create_all()来避免创建新表，只初始化现有表
    pass

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')